.TH LLN.H 1 "2025-05-30" "LLinal" "Header Manual"

.SH NAME
lln.h \- LLinal runtime API header for embedding and running \fB.lln\fR scripts

.SH SYNOPSIS
.nf
#include "lln.h"
.fi

.SH DESCRIPTION
\fIlln.h\fR provides the core C runtime API for executing LLinal scripts (\fB.lln\fR files). 
It defines types, macros, and functions to parse command arguments, register commands, 
and run scripts interpreted by the LLinal runtime.

The header enables writing C programs that expose commands callable from \fB.lln\fR scripts, 
manage typed arguments, and run scripts dynamically or via preprocessed files.

.SH FEATURES
.IP \[bu] 2
Dynamic arrays for managing command lists and arguments.
.IP \[bu] 2
StringBuilder utility for efficient string construction.
.IP \[bu] 2
Typed command arguments with support for \fBint\fR, \fBfloat\fR, \fBbool\fR, and \fBstring\fR.
.IP \[bu] 2
Command registration macros simplifying declaration and binding of command handler functions.
.IP \[bu] 2
Runtime entry function to execute \fB.lln\fR scripts with registered commands.

.SH USAGE

.TP
\fBManual Setup\fR

To embed LLinal commands in your C program:

.IP \fB1.\fR
Include \fIlln.h\fR.

.IP \fB2.\fR
Declare commands using \fILLN_declare_command\fR or \fILLN_declare_command_custom_name\fR, 
providing the command name, function, and argument types.

.PP
Example:
.nf
.LP
LLN_declare_command(foo, ARG_INT, ARG_STR) {
    int x = LLN_arg_int(0);
    char *s = LLN_arg_str(1);
    // Command implementation here
    return NULL;
}
.fi

.IP \fB3.\fR
Create and initialize an \fIlln_Callables\fR structure to hold commands.

.IP \fB4.\fR
Use \fILLN_register_command\fR to add commands to this structure.

.IP \fB5.\fR
Optionally define pre- and post-run hooks with \fILLN_declare_pre\fR and \fILLN_declare_post\fR.

.IP \fB6.\fR
Call \fIlln_run_lln_file("script.lln", &callables)\fR to execute the script.

.TP
\fBUsing the Preprocessed Shortcut\fR

When compiling code generated by the LLinal preprocessor (\fBlln -p\fR), the preprocessed C file defines \fB__LLN_PREPROCESSED_FILE\fR.

In this mode:

.IP \fB•\fR
Use the macro \fIlln_run(filename)\fR to run a \fB.lln\fR script directly.

.IP \fB•\fR
Pre- and post-run hooks and commands are registered automatically.

.IP \fB•\fR
No need to manually register commands or call \fIlln_run_lln_file\fR.

.SH API DETAILS

.SH Types

.TP
\fBlln_ArgType\fR

Enumeration of argument types:
.IP
\fBARG_INT\fR — Integer argument.
.IP
\fBARG_FLT\fR — Floating-point argument.
.IP
\fBARG_STR\fR — String argument.
.IP
\fBARG_BOOL\fR — Boolean argument.

.TP
\fBlln_Arg\fR

Union of a typed argument value paired with its type.

.TP
\fBlln_Args\fR

Dynamic array of \fBlln_Arg\fR representing command arguments.

.TP
\fBlln_Callable\fR

Represents a registered command with a name, argument signature, and handler function pointer.

.TP
\fBlln_Callables\fR

Collection of \fBlln_Callable\fR commands, plus optional pre- and post-run hooks.

.SH Macros

.TP
\fBLLN_declare_command(name, ...)\fR

Declare a command handler function and its argument signature.
Commands must have names starting with '!' internally but this macro auto-prepends it.

.TP
\fBLLN_declare_command_custom_name(cmdname, fnname, ...)\fR

Declare a command with a custom command string name (must start with '!').

.TP
\fBLLN_register_command(callables, fnname)\fR

Append a declared command to a callables list.

.TP
\fBLLN_arg_int(i)\fR, \fBLLN_arg_str(i)\fR, \fBLLN_arg_flt(i)\fR, \fBLLN_arg_bool(i)\fR

Macros to extract typed arguments inside command handlers by index.

.SH Functions

.TP
\fIlln_run_lln_file(const char *filename, const lln_Callables *c)\fR

Run the given \fB.lln\fR script file using the registered commands in \fBc\fR.

.TP
String builder utilities:

\fIlln_sb_append(), lln_sb_term(), lln_sb_new_cstr(), \dots\fR  
Use for efficient dynamic string construction.

.SH PREFIX USAGE

By default, LLinal symbols (types, functions, macros) are prefixed with \fBlln_\fR to avoid name collisions.
For example, \fBlln_Callable\fR and \fBlln_run_lln_file()\fR.

If you define the macro \fBLLN_STRIP_PREFIX\fR before including \fIlln.h\fR, this prefix will be \fBremoved\fR,
and the symbols become \fBCallable\fR and \fBrun_lln_file()\fR respectively.

This option is useful if you want to use the LLinal API without prefixing, or integrate with code
that expects the unprefixed symbol names.

Example:

.nf
#define LLN_STRIP_PREFIX
#include "lln.h"
.fi

.SH EXAMPLE

.nf
#include "lln.h"

LLN_declare_command(print_int, ARG_INT) {
    int value = LLN_arg_int(0);
    printf("Value: %d\n", value);
    return NULL;
}

int main() {
    lln_Callables callables = {0};
    LLN_register_command(&callables, print_int);
    lln_run_lln_file("example.lln", &callables);
    return 0;
}
.fi

.SH NOTES

.TP
All command functions must accept a single \fIlln_Args\fR parameter and return \fBvoid*\fR. The return value is currently unused and can be NULL.

.TP
Command names must start with the \fB'!'\fR character internally. Use the declaration macros to ensure this.

.TP
Dynamic arrays automatically grow as needed.

.SH SEE ALSO
lln(1), lln-preproc(1), .lln(5)
